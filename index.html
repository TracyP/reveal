<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reveal</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f0f0f0; overflow-x: hidden; }
    #game { margin-top: 50px; }
    #wordWrapper {
      display: inline-block;
      padding: 15px;
      border: 3px solid transparent;
      border-radius: 10px;
      margin-bottom: 20px;
    }
    #wordWrapper.complete {
      animation: pulse-border 1s ease-out;
      border-color: #4caf50;
    }
    @keyframes pulse-border {
      0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
      50% { box-shadow: 0 0 15px 5px rgba(76, 175, 80, 0.4); }
      100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
    }
    #word { display: flex; justify-content: center; gap: 10px; }
    .tile {
      width: 40px; height: 40px;
      display: flex; align-items: center; justify-content: center;
      background: #ddd;
      font-size: 1.5em;
      font-weight: bold;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      text-transform: uppercase;
      border: none;
    }
    .tile.correct { background: #4caf50; color: white; }
    .tile.hint { background: #aaa; color: white; }
    .keyboard { display: flex; flex-direction: column; align-items: center; }
    .keyrow { display: flex; justify-content: center; margin: 5px 0; }
    .key {
      width: 40px; height: 40px; margin: 2px; border: none;
      background: #ddd; font-size: 1em; cursor: pointer; border-radius: 4px;
      user-select: none;
    }
    .key.correct { background: #4caf50; color: white; }
    .key.wrong { background: #f44336; color: white; }
    .key.hintkey { background: #aaa; color: white; cursor: default; }
    .key.disabled { cursor: not-allowed; opacity: 0.6; }
    #summary { margin-top: 30px; font-weight: bold; white-space: pre-line; }
    #share { margin-top: 10px; cursor: pointer; color: #007BFF; text-decoration: underline; }
    #helpButton { margin-top: 20px; display: inline-block; padding: 10px 20px; background: #007BFF; color: white; border: none; border-radius: 4px; cursor: pointer; text-decoration: none; font-size: 1em; }
    #confetti-canvas { position: fixed; pointer-events: none; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; }
    #modeIndicator { margin-top: 8px; font-style: italic; color: #555; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="encryptedWords.js"></script>
</head>
<body>
  <h1>Reveal</h1>
  <div id="modeIndicator"></div>
  <div id="game">
    <canvas id="confetti-canvas"></canvas>
    <div id="wordWrapper"><div id="word"></div></div>
    <div class="keyboard" id="keyboard"></div>
    <div id="summary"></div>
    <div id="share" onclick="shareResult()"></div>
    <button id="helpButton" onclick="location.href='help.html'">How to Play</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <script>
    // === Configuration ===
    const testingMode = true; // true = new word every minute, false = daily
    const secondsPerPuzzle = testingMode ? 60 : 86400;

    // Anchor time set to top of the current hour (testing) or start of day (prod)
    const now = new Date();
    const anchorTime = testingMode
      ? new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0)
      : new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // Puzzle index calculation based on elapsed time since anchorTime
    const puzzleIndex = Math.floor((Date.now() - anchorTime.getTime()) / (secondsPerPuzzle * 1000));

    // Display mode
    const modeIndicator = document.getElementById("modeIndicator");
    modeIndicator.textContent = testingMode
      ? "ðŸ§ª Testing Mode (1-minute puzzles)"
      : "ðŸ§© Daily Puzzle Mode";

    // Pseudo-random mod function for cycling words after the sequential list exhausted
    function pseudoRandomModIndex(index, max) {
      const seed = index.toString().split('').reduce((a, b) => a + parseInt(b), 0);
      return (index * 17 + seed) % max;
    }

    // Determine word index: sequential for first words, then pseudo-random mod
    let wordIndex;
    if (puzzleIndex < encryptedWords.length) {
      wordIndex = puzzleIndex;
    } else {
      wordIndex = pseudoRandomModIndex(puzzleIndex, encryptedWords.length);
    }

    // Decrypt the chosen word
    const decrypted = CryptoJS.AES.decrypt(encryptedWords[wordIndex], "base64" + wordIndex);
    const word = decrypted.toString(CryptoJS.enc.Utf8).toUpperCase();

    // Game state
    const wordDisplay = document.getElementById("word");
    const keyboardContainer = document.getElementById("keyboard");
    const summary = document.getElementById("summary");
    const shareDiv = document.getElementById("share");

    let guessed = new Set();
    let revealed = Array(word.length).fill(false);
    let stats = { correct: 0, hints: 0 };
    let guessCount = 0;
    const startTime = Date.now();
    let gameOver = false;

    // Check localStorage if puzzle completed before
    const completedKey = `reveal-completed-${puzzleIndex}`;
    const savedDataRaw = localStorage.getItem(completedKey);
    if (savedDataRaw) {
      // Load saved stats and set game over & reveal all letters
      const savedData = JSON.parse(savedDataRaw);
      guessed = new Set(savedData.guessed || []);
      revealed = Array(word.length).fill(true);
      stats = { correct: savedData.correct || 0, hints: savedData.hints || 0 };
      guessCount = savedData.guessCount || 0;
      gameOver = true;
      showEndState();
    }

    // Render the word tiles
    function renderWord() {
      wordDisplay.innerHTML = "";
      for (let i = 0; i < word.length; i++) {
        const tile = document.createElement("div");
        tile.className = "tile";
        if (revealed[i]) {
          tile.classList.add(guessed.has(word[i]) ? "correct" : "hint");
          tile.textContent = word[i];
        } else {
          tile.textContent = "";
        }
        wordDisplay.appendChild(tile);
      }
    }

    // QWERTY keyboard layout
    const keyboardRows = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];

    // Render keyboard buttons
    function renderKeyboard() {
      keyboardContainer.innerHTML = "";
      for (const row of keyboardRows) {
        const rowDiv = document.createElement("div");
        rowDiv.className = "keyrow";
        for (const char of row) {
          const btn = document.createElement("button");
          btn.textContent = char;
          btn.className = "key";
          btn.id = `key-${char}`;

          // If game over or this letter was guessed, disable button and set correct class
          if (gameOver) {
            btn.disabled = true;
            btn.classList.add("disabled");
            if (guessed.has(char)) {
              if (word.includes(char)) btn.classList.add("correct");
              else btn.classList.add("wrong");
            } else if (revealed.some((v,i) => word[i] === char && !guessed.has(char))) {
              btn.classList.add("hintkey");
              btn.disabled = true;
            }
          } else {
            if (guessed.has(char)) {
              if (word.includes(char)) btn.classList.add("correct");
              else btn.classList.add("wrong");
              btn.disabled = true;
              btn.classList.add("disabled");
            } else {
              btn.onclick = () => guessLetter(char);
            }
          }

          rowDiv.appendChild(btn);
        }
        keyboardContainer.appendChild(rowDiv);
      }
    }

    // Update keyboard key status and disable appropriately
    function updateKeyboard(letter, result) {
      const btn = document.getElementById(`key-${letter}`);
      if (!btn) return;
      btn.classList.add(result);
      if (result === "hintkey" || result === "correct" || result === "wrong") {
        btn.disabled = true;
        btn.classList.add("disabled");
      }
    }

    // Disable all keyboard keys when game ends
    function disableAllKeys() {
      document.querySelectorAll(".key").forEach(btn => {
        btn.disabled = true;
        btn.classList.add("disabled");
      });
    }

    // Show end-of-game state: reveal all letters, disable keys, show stats
    function showEndState() {
      revealed.fill(true);
      renderWord();
      renderKeyboard();
      document.getElementById("wordWrapper").classList.add("complete");
      disableAllKeys();

      const duration = Math.round((Date.now() - startTime) / 1000);
      summary.textContent = `âœ… You revealed the word!\nCorrect guesses: ${stats.correct}\nHints used: ${stats.hints}\nTime: ${duration}s`;
      shareDiv.textContent = "Share your result";
    }

    // Main guess handler
    function guessLetter(letter) {
      if (gameOver) return;
      if (guessed.has(letter)) return;
      guessed.add(letter);
      guessCount++;

      let matched = false;
      for (let i = 0; i < word.length; i++) {
        if (word[i] === letter) {
          revealed[i] = true;
          matched = true;
        }
      }

      if (matched) {
        stats.correct++;
        updateKeyboard(letter, "correct");
      } else {
        updateKeyboard(letter, "wrong");
        // Only start giving hints after 3 guesses
        if (guessCount > 3) {
          for (let i = 0; i < word.length; i++) {
            if (!revealed[i]) {
              revealed[i] = true;
              updateKeyboard(word[i], "hintkey");
              stats.hints++;
              break;
            }
          }
        }
      }

      renderWord();
      checkComplete();
    }

    // Check if all letters revealed (game complete)
    function checkComplete() {
      if (revealed.every(val => val)) {
        gameOver = true;
        document.getElementById("wordWrapper").classList.add("complete");
        disableAllKeys();

        const duration = Math.round((Date.now() - startTime) / 1000);
        summary.textContent = `âœ… You revealed the word!\nCorrect guesses: ${stats.correct}\nHints used: ${stats.hints}\nTime: ${duration}s`;

        // Save completion info for this puzzleIndex
        localStorage.setItem(completedKey, JSON.stringify({
          correct: stats.correct,
          hints: stats.hints,
          guessCount: guessCount,
          guessed: Array.from(guessed)
        }));

        // Show confetti
        confetti({
          particleCount: 150,
          spread: 70,
          origin: { y: 0.6 }
        });

        shareDiv.textContent = "Share your result";
      }
    }

    // Share game result text
    function shareResult() {
      if (!gameOver) return alert("Finish the puzzle first!");
      const statsStoredRaw = localStorage.getItem(completedKey);
      if (!statsStoredRaw) return alert("No stats to share.");

      const statsStored = JSON.parse(statsStoredRaw);

      const shareText = `Reveal ${puzzleIndex}: ${statsStored.correct} correct, ${statsStored.hints} hint${statsStored.hints !== 1 ? 's' : ''}, \nhttps://tracyp.github.io/reveal/`;
      navigator.clipboard.writeText(shareText).then(() => {
        alert("Copied to clipboard:\n" + shareText);
      }).catch(() => {
        alert("Failed to copy to clipboard. Here's your result:\n" + shareText);
      });
    }

    // Init render
    renderWord();
    renderKeyboard();

  </script>
</body>
</html>
